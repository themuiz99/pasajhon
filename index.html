<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡πÄ‡∏ß‡πá‡∏ö‡πÅ‡∏õ‡∏•‡∏†‡∏≤‡∏©‡∏≤‡πÇ‡∏à‡∏£</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font for better Thai display */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure no vertical scrolling by making sure content fits viewport */
        html, body {
            /* overflow-y: hidden; Removed to allow body to stretch, rely on inner container for overflow */
            height: 100%; /* ‡∏ó‡∏≥‡πÉ‡∏´‡πâ body ‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ */
            margin: 0; /* Remove default body margin */
            padding: 0; /* Remove default body padding */
        }
        .full-screen-container {
            min-height: 100vh; /* Make sure this container takes full viewport height */
            width: 100%; /* Take full viewport width */
            display: flex; /* Use flexbox for centering */
            align-items: center; /* Center content vertically */
            justify-content: center; /* Center content horizontally */
            padding: 1rem; /* Add some padding around the main content */
            box-sizing: border-box; /* Include padding in the element's total width and height */
            background: linear-gradient(to bottom right, #1f2937, #000000); /* Apply background gradient here */
        }
        .content-card {
            background-color: #1f2937; /* Background color for the card */
            padding: 1.5rem; /* Padding inside the card */
            border-radius: 1rem; /* Rounded corners for the card */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.4); /* Enhanced shadow */
            width: 100%; /* Full width within its container */
            max-width: 42rem; /* Max width for larger screens (equivalent to max-w-2xl) */
            transform: scale(1); /* Initial scale */
            transition: all 0.3s ease-in-out; /* Smooth transition for hover effect */
            position: relative; /* Essential for absolute positioning of message box */
            /* Ensure inner content can scroll if it overflows the card height */
            display: flex;
            flex-direction: column;
            gap: 1.5rem; /* Spacing between sections */
            /* Add this to allow inner scrolling if content exceeds viewport height */
            max-height: calc(100vh - 2rem); /* Calculate max height based on viewport and body padding */
            overflow-y: auto; /* Allow scrolling within the card if content is too long */
        }

        /* Specific adjustments for smaller screens, Tailwind handles most responsiveness */
        @media (max-width: 640px) { /* Small screens */
            .text-4xl {
                font-size: 2.5rem; /* Adjust heading size for very small screens */
            }
            .text-lg {
                font-size: 1rem; /* Adjust label font size */
            }
            .py-3 {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
            }
            .px-8 {
                padding-left: 1.5rem;
                padding-right: 1.5rem;
            }
            .py-2 {
                padding-top: 0.375rem;
                padding-bottom: 0.375rem;
            }
            .px-4 {
                padding-left: 0.75rem;
                padding-right: 0.75rem;
            }
        }
    </style>
</head>
<!-- Body now contains a full-screen-container to ensure background covers everything -->
<body class="bg-black"> <!-- Removed gradient from body to apply to full-screen-container -->
    <div class="full-screen-container">
        <div class="content-card">
            <h1 class="text-4xl font-extrabold text-center text-gray-100 mb-6">
                ‡πÄ‡∏ß‡πá‡∏ö‡πÅ‡∏õ‡∏•‡∏†‡∏≤‡∏©‡∏≤‡πÇ‡∏à‡∏£ ü§´
            </h1>

            <div class="mb-3">
                <label for="sourceInput" class="block text-gray-300 text-lg font-semibold mb-2">
                    ‡∏°‡∏∂‡∏á‡∏à‡∏∞‡∏û‡∏¥‡∏°‡∏û‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏õ‡∏•‡∏≠‡∏∞‡πÑ‡∏£? ‡∏Å‡πá‡∏Å‡∏£‡∏≠‡∏Å‡∏•‡∏á‡πÑ‡∏õ!
                </label>
                <!-- Source input textarea for user to type text -->
                <textarea id="sourceInput" rows="3"
                    class="w-full p-3 border border-gray-600 rounded-lg bg-gray-700 text-gray-50 focus:ring-blue-500 focus:border-blue-500 text-base resize-none shadow-sm"
                    placeholder="‡πÄ‡∏ä‡πà‡∏ô ‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏™‡∏ö‡∏≤‡∏¢‡∏î‡∏µ‡πÑ‡∏´‡∏°‡∏Ñ‡∏∞? ‡∏´‡∏£‡∏∑‡∏≠ zax3des0lkm9a2c_sp_lko3o2i..."></textarea>
            </div>

            <!-- Button to clear the source input, replacing the old translate button -->
            <div class="flex justify-center mb-5">
                <button id="clearSourceInputBtn"
                    class="bg-red-600 hover:bg-red-700 text-white font-bold py-2.5 px-7 rounded-full shadow-lg transform transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 text-lg">
                    ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô üóëÔ∏è
                </button>
            </div>

            <div class="mb-3">
                <label for="targetOutput" class="block text-gray-300 text-lg font-semibold mb-2">
                    ‡∏Å‡∏π‡πÅ‡∏õ‡∏•‡πÉ‡∏´‡πâ‡∏•‡πà‡∏∞.. ‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏°‡∏∂‡∏á!
                </label>
                <!-- Target output textarea to display translated text -->
                <textarea id="targetOutput" rows="3" readonly
                    class="w-full p-3 border border-gray-600 rounded-lg bg-gray-700 text-gray-50 focus:ring-blue-500 focus:border-blue-500 text-base resize-none shadow-sm"
                    placeholder="‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏à‡∏∞‡∏õ‡∏£‡∏≤‡∏Å‡∏è‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà..."></textarea>
                <!-- Only the copy button remains at the bottom right -->
                <div class="flex flex-col sm:flex-row justify-end gap-2 mt-3">
                    <button id="copyOutputBtn"
                        class="bg-green-500 hover:bg-green-600 text-white font-bold py-1.5 px-3 rounded-full shadow-md transform transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-offset-2 text-sm">
                        ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå üìã
                    </button>
                </div>
            </div>

            <!-- Message box for displaying feedback to the user, now absolutely positioned to prevent layout shifts -->
            <!-- Positioned relative to .content-card, centered at the bottom -->
            <div id="messageBox" class="hidden absolute bottom-4 left-1/2 -translate-x-1/2 w-11/12 max-w-sm bg-blue-900 border border-blue-700 text-blue-200 px-4 py-3 rounded-lg z-50" role="alert">
                <strong class="font-bold">‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°:</strong>
                <span class="block sm:inline" id="messageText"></span>
                <!-- Close button for the message box -->
                <span class="absolute top-0 bottom-0 right-0 px-4 py-3 cursor-pointer" onclick="document.getElementById('messageBox').classList.add('hidden');">
                    <svg class="fill-current h-6 w-6 text-blue-400" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>‡∏õ‡∏¥‡∏î</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 2.65a1.2 1.2 0 1 1-1.697-1.697L8.303 10l-2.651-2.651a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-2.651a1.2 1.2 0 1 1 1.697 1.697L11.697 10l2.651 2.651a1.2 1.2 0 0 1 0 1.698z"/></svg>
                </span>
            </div>

            <div class="text-center text-gray-400 text-sm mt-5">
                Created by - TheMuiz X ‡∏°‡∏∞‡∏•‡∏¥
            </div>
        </div>
    </div>

    <script>
        // Mapping Thai characters to unique gibberish strings
        const thaiToGibberishMap = new Map([
            ['‡∏Å', 'zax3'], ['‡∏Ç', 'qwe7'], ['‡∏Ñ', 'asd9'], ['‡∏á', 'fgh2'], ['‡∏à', 'jkl5'],
            ['‡∏â', 'poi1'], ['‡∏ä', 'uyt6'], ['‡∏ã', 'rew8'], ['‡∏å', 'cvb4'], ['‡∏ç', 'nmk0'],
            ['‡∏é', 'lko3'], ['‡∏è', 'ijh7'], ['‡∏ê', 'gfd9'], ['‡∏ë', 'saq2'], ['‡∏í', 'wex5'],
            ['‡∏ì', 'dcr1'], ['‡∏î', 'vft6'], ['‡∏ï', 'bgy8'], ['‡∏ñ', 'nhu4'], ['‡∏ó', 'mjy0'],
            ['‡∏ò', 'ikl3'], ['‡∏ô', 'opm7'], ['‡∏ö', 'lkm9'], ['‡∏õ', 'njh2'], ['‡∏ú', 'gfv5'],
            ['‡∏ù', 'cdx1'], ['‡∏û', 'zse6'], ['‡∏ü', 'qaz8'], ['‡∏†', 'wsx4'], ['‡∏°', 'edc0'],
            ['‡∏¢', 'rfv3'], ['‡∏£', 'tgb7'], ['‡∏•', 'yhn9'], ['‡∏ß', 'ujm2'], ['‡∏®', 'ikn5'],
            ['‡∏©', 'olm1'], ['‡∏™', 'pko6'], ['‡∏´', 'ijh8'], ['‡∏¨', 'gfr4'], ['‡∏≠', 'des0'],
            ['‡∏Æ', 'xza3'],
            ['‡∏∞', 'a1b'], ['‡∏≤', 'a2c'], ['‡∏¥', 'i1d'], ['‡∏µ', 'i2e'], ['‡∏∂', 'u1f'],
            ['‡∏∑', 'u2g'], ['‡∏∏', 'o1h'], ['‡∏π', 'o2i'], ['‡πÄ', 'e1j'], ['‡πÅ', 'e2k'],
            ['‡πÇ', 'o3l'], ['‡πÉ', 'a3m'], ['‡πÑ', 'a4n'], ['‡∏≥', 'amx'], ['‡∏§', 'ruy'],
            ['‡∏¶', 'luz'],
            ['‡πá', 't1p'], ['‡πà', 't2q'], ['‡πâ', 't3r'], ['‡πä', 't4s'], ['‡πã', 't5t'],
            ['‡πÜ', 'repx'], ['‡∏Ø', 'etcy'],
            ['‡πê', 'n0a'], ['‡πë', 'n1b'], ['‡πí', 'n2c'], ['‡πì', 'n3d'], ['‡πî', 'n4e'],
            ['‡πï', 'n5f'], ['‡πñ', 'n6g'], ['‡πó', 'n7h'], ['‡πò', 'n8i'], ['‡πô', 'n9j'],
            [' ', '_sp_'], ['.', '_dot_'], [',', '_com_'], ['?', '_que_'], ['!', '_exc_'],
            ['(', '_opn_'], [')', '_cls_'], ['-', '_dsh_'], ['+', '_pls_'], ['=', '_eql_'],
            ['/', '_slh_'], ['\\', '_bsh_'], ['*', '_str_'], ['&', '_amp_'], ['%', '_pct_'],
            ['#', '_hsh_'], ['@', '_at_'], ['$', '_dlr_'], ['^', '_crt_'], ['<', '_lt_'],
            ['>', '_gt_'], ['[', '_obr_'], [']', '_cbr_'], ['{', '_ocu_'], ['}', '_ccu_'],
            [':', '_col_'], [';', '_scl_'], ['"', '_dqt_'], ["'", '_sqt_'], ['`', '_bkt_'],
            ['~', '_tld_'], ['|', '_pip_']
        ]);

        // Create a reverse map for decoding
        const gibberishToThaiMap = new Map();
        for (let [thaiChar, gibberishString] of thaiToGibberishMap.entries()) {
            gibberishToThaiMap.set(gibberishString, thaiChar);
        }

        // Sort gibberish keys by length in descending order to ensure longest match first during decoding
        const sortedGibberishKeys = Array.from(gibberishToThaiMap.keys()).sort((a, b) => b.length - a.length);

        const sourceInput = document.getElementById('sourceInput');
        const targetOutput = document.getElementById('targetOutput');
        const clearSourceInputBtn = document.getElementById('clearSourceInputBtn'); // Button to clear source input
        const copyOutputBtn = document.getElementById('copyOutputBtn');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');

        // Function to show a message in the message box
        function showMessage(message, type = 'info') {
            messageText.textContent = message;
            messageBox.classList.remove('hidden');
            if (type === 'error') {
                messageBox.classList.remove('bg-blue-900', 'border-blue-700', 'text-blue-200');
                messageBox.classList.add('bg-red-900', 'border-red-700', 'text-red-200');
            } else {
                messageBox.classList.remove('bg-red-900', 'border-red-700', 'text-blue-200');
                messageBox.classList.add('bg-blue-900', 'border-blue-700', 'text-blue-200');
            }
            // Automatically hide the message after 3 seconds
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 3000);
        }

        // Function to translate Thai to Gibberish
        function thaiToGibberishTranslator(text) {
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (thaiToGibberishMap.has(char)) {
                    result += thaiToGibberishMap.get(char);
                } else {
                    // If character is not in our map (e.g., English letters, other symbols), keep it as is
                    result += char;
                }
            }
            return result;
        }

        // Function to translate Gibberish to Thai
        function gibberishToThaiTranslator(text) {
            let result = '';
            let i = 0;
            while (i < text.length) {
                let matched = false;
                // Try to match the longest possible gibberish key first
                for (const gibberishKey of sortedGibberishKeys) {
                    if (text.substring(i, i + gibberishKey.length) === gibberishKey) {
                        result += gibberishToThaiMap.get(gibberishKey);
                        i += gibberishKey.length;
                        matched = true;
                        break; // Move to the next part of the text after a match
                    }
                }
                if (!matched) {
                    // If no gibberish key matches, assume it's an original character (e.g., English letter or unmatched symbol)
                    result += text[i];
                    i++;
                }
            }
            return result;
        }

        // Function to detect if the input text is likely gibberish
        function isGibberish(text) {
            // Check if the text contains at least one of our gibberish codes
            // A more robust check might involve checking the ratio of gibberish codes to regular characters
            for (const gibberishKey of sortedGibberishKeys) {
                if (text.includes(gibberishKey)) {
                    return true;
                }
            }
            // If no known gibberish codes are found, assume it's Thai
            return false;
        }

        // Event listener for source input to perform automatic translation
        sourceInput.addEventListener('input', () => {
            const inputText = sourceInput.value.trim();
            if (inputText === '') {
                targetOutput.value = ''; // Clear output if input is empty
                messageBox.classList.add('hidden'); // Hide message
                return;
            }

            if (isGibberish(inputText)) {
                // If it looks like gibberish, translate to Thai
                const thaiText = gibberishToThaiTranslator(inputText);
                targetOutput.value = thaiText;
            } else {
                // Otherwise, assume it's Thai and translate to gibberish
                const gibberishText = thaiToGibberishTranslator(inputText);
                targetOutput.value = gibberishText;
            }
            // Hide message box after translation to avoid clutter unless there's an error.
            if (!messageBox.classList.contains('bg-red-900')) { // Don't hide if it's an error message
                messageBox.classList.add('hidden');
            }
        });


        // Event listener for "Copy Output" button
        copyOutputBtn.addEventListener('click', () => {
            const outputText = targetOutput.value;
            if (outputText === '') {
                showMessage('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÉ‡∏´‡πâ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏ô‡∏∞‡∏Ñ‡∏∞!', 'error');
                return;
            }
            targetOutput.select();
            targetOutput.setSelectionRange(0, 99999); // For mobile devices
            try {
                document.execCommand('copy');
                showMessage('‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏∞! ‚úÖ');
            } catch (err) {
                showMessage('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏Ñ‡πà‡∏∞ ‡∏•‡∏≠‡∏á‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏î‡∏π‡∏ô‡∏∞‡∏Ñ‡∏∞ üôÅ', 'error');
            }
        });

        // Event listener for the new "Clear Source Input" button
        clearSourceInputBtn.addEventListener('click', () => {
            sourceInput.value = '';
            targetOutput.value = ''; // Also clear the target output
            showMessage('‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏∞! üßπ');
        });

        // Optional: Clear target output and hide message when typing in source input
        sourceInput.addEventListener('input', () => {
            if (targetOutput.value !== '') {
                // The auto-translation will handle updating, so no need to clear here.
            }
        });
    </script>
</body>
</html>

